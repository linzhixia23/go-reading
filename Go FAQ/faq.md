原文：https://golang.org/doc/faq

<br>

### 一、起源

##### 1、Go项目的目的？
在go开始的时候，也就是十多年前，程序的世界跟今天是不同的。
那时，软件生产通常是用C++或Java，Github还不存在，大多数计算机还不是多处理器，除了Visual Studio和Eclipse，几乎很少有高阶的开发工具，更不用说那时的互联网还不是免费的。

同时，我们还经常被过度复杂的软件变成语言搞得很崩溃。
自从C++和Java问世之后，计算机的性能有了很大的提高，但编程语言本身没有很大的进步。
显然，多处理器已然成为主流，但现在的编程语言在提高它们的性能和安全方面，做的还不够。

我们决定退后一步，来思考随着技术的进步，未来十几年，对软件工程来说，最重要的事情是什么，以及如何运用新的技术去解决它们。
例如，随着多核处理器的增加，就需要编程语言对并行和并发提供first-class的支持。
以及，为了易于在高并发的程序中进行资源管理，就需要垃圾回收机制，至少是安全的自动内存管理技术。

这些思考从Go开始时就引起了广泛的思考和[讨论](https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html),起初是思想的碰撞，后面把它变成了语言。
整体的目标是，go为工作的程序员提供工具以处理日常的任务，如代码的格式化等，为编写大型的代码扫除障碍。

关于更多Go的详尽描述，以及它们如何实现目标的，可以在这篇[文档](https://talks.golang.org/2012/splash.article)找到。

##### 2、Go项目的历史？

Robert Griesemer, Rob Pike and Ken Thompson于2017年9月21日开始在白板上列举了新语言的目标。
在几天内，目标就定下来要做什么，以及明确了它是什么样的。他们主要在业余时间进行设计。
到2008年1月，Ken开始就探索这个想法开发编译器；它以C代码做为它的输出。
到了年中，开发新语言成为了一个full-time的项目，而且有了一个生产级别的编译器。
在2008年5月，Ian Taylor基于草案，开始独立开发go的gcc前端。
Russ Cox在2008年底加入项目，并把语言和库从原型变成了实现。

在2009年11月，go成为了一个公开的开源项目。无数的社区开源者为其贡献想法、讨论和代码。

现在全球有上百万的go程序员（自称：gopher），而且每天还在增加。go的成功已经超出了我们的预期。

##### 3、Go吉祥物的由来。
吉祥物和Logo是Renée French设计的，她同时也是the Plan 9 bunny的设计者。
这篇博客说明了她如何从WFMU的T-shirt获得灵感。Logo和吉祥物是受Creative Commons Attribution 3.0证书保护。

gopher有一个[model sheet](https://golang.org/doc/gopher/modelsheet.jpg)来阐述如何准确地表达他们的个性。
这个model sheet最早在Renée at Gophercon2016年的演讲里出现。
它有独特的特征；它是go的gopher，不是什么老的gopher。
（原话是，he's the Go gopher, not just any old gopher。感觉是go和old两个词谐音，用来开玩笑）

##### 4、到底叫Go还是Golang？
编程语言叫Go。Golang的绰号来自于Go的网站是golang.org，而不是go.org--这个域名已经被占用了。
很多人用golan这个名字，它很方便做为标签。例如，twitter的标签就是"#golang"，尽管它的名字就只是Go。

尽管官方的LOGO是两个大写字母，但编程语言的名字是Go，而不是GO。

##### 5、为什么要创造一门新的语言？
Go起源于我们用现有语言和环境在谷歌工作时遇到的一些困难。编程变得很困难，而这部分归因于语言的选择。
我们必须要从高效地编译、高效地执行以及容易开发中作出选择；没有主流语言能同时满足这三个因素。
程序员如果希望忽略安全性，以及提高效率，那么可以选择动态类型的语言，比如python和JS，而不是C++或者Java。

我们不仅只停留在担心阶段。（原话是，We were not alone in our concerns。不知道理解对没有）。
编程语言的发展历程在多年的沉寂之后，go是几种语言（Rust, Elixir, Swift等）中第一个成为活跃的主流的语言的。

Go结合了解释执行的动态语言的简易性，以及编译执行的静态语言的安全性，很好地解决了这些问题。
它同时是面向现代的网络化和多核化计算。
最后，用go的目的是为了快：它应该在几秒内就可以在单机上构建一个大型的可执行程序。
要达到这些目标，要解决大量的语言的问题（linguistic issue）：一个表达丰富但轻量的类型体系；并发执行和垃圾回收；严格依赖的描述，等等。
这些问题不能通过工具或者库来解决，我们需要一门新的语言。

文章Go at Google讨论了go语言设计的背景和思想，以及这篇faq之外的更多细节。

##### 6、Go的祖先是谁？
Go主要来源于C家族（基础语法），同时大量吸收了Pascal/Modula/Oberon家族的设计（声明，包），加上基于Tony Hoare的CSP理论的语言Newsqueak/Limbo等的思想（并发）。
当然，这是一门全新的语言。
在该语言设计的每个方面，都会考虑程序员要做什么，如何使编程更加高效而有乐趣。

##### 7、在设计中的指导原则是什么？
在Go设计之初，写服务最常用的语言是Java和C++，至少在Google是这样。
我们感觉这些语言繁琐而重复（原话是，bookkeeping and repetition）。
一些语言开始转向流式的动态语言，例如python，但这样是以安全性和效率为代价的。
我们感觉应该有一个集合了高效、安全、易变（fluidity）的语言。

Go尝试去减少关键词的二义性（原话是，Go attempts to reduce the amount of typing in both senses of the word）。
通过它的设计，我们尝试去减少它的复杂度。它没有前置声明和头文件；任何东西只要声明一次。
初始化是明确的、自动的、容易使用的。语法的用关键词表达是很清晰的。
像这样 foo.Foo* myFoo = new(foo.Foo) 这样啰嗦的语法， 可以通过 := 这个符号来表示"声明并初始化"的构造。
另外，可能是最根本的区别，go没有类型层级（type hierarchy）：类型不需要声明它们的关系。
这些简洁的特性，使得Go表达清晰，易于理解，而不失高雅。

另外一个重要的原则是，保持概念正交。方法可用于任何类型；结构用于数据；接口用于抽象。
正交概念使得在各种东西融合时，更容易理解。

### 二、用法

##### 1、谷歌内部在使用Go吗？

是的。Go广泛用于谷歌内部的产品。一个简单的例子就是[golang.org](https://golang.org/)服务.
它是一个godoc的文件服务，运行在基于Google App Engine的产品上。

另一个更重要的例子是，谷歌的下载服务，dl.google.com，它传送Chrome的二进制文件，或者其他大型的安装包，如apt-get包。

Go远不是谷歌唯一使用的语言，但它是很多领域的关键性语言，包括万盏可靠性工程（SRE）和大数据处理。

##### 2、还有哪些其他公司在用Go？

Go的使用者在全球范围增长，尤其是在云计算时代。（原话是，Go usage is growing worldwide, especially but by no means exclusively in the cloud computing space。感觉没理解）。
主要的基于go的云框架项目是Docker和Kubernetes，除了这些还有很多。

不仅仅是云。Go的wiki包含了一个(网页)[https://github.com/golang/go/wiki/GoUsers], 列举了许多使用go的公司的典型代表。

Wiki上同样有用Go的公司和项目的(成功案例)[https://github.com/golang/go/wiki/SuccessStories]

##### 3、Go程序和C/C++程序可以链接吗？

在同样的地址空间使用C和Go是可以的，但它不是天然就能结合（not a natural fit），它需要特殊的接口软件。
同时，把C和Go代码链接在一起，就放弃了GO提供的内存安全和栈管理的特性。
有时，用C的库来解决问题是有必要的，但频繁地使用会引入一些纯Go代码没有的风险，因此这样做必须谨慎。

Gc用了不同于C的调用协议和链接器，因此不能直接从C程序调用。
cgo项目提供了一个机制，使得"外部函数接口"允许go代码安全调用C的库。SWIG把这个能力扩展到了C++库。

你可以通过Gccgo和gollvm来使用cgo和SWIG。
因为它们使用传统的API，因此可以把GCC/LLVM编译过的C/C++程序通过编译器链接在一起。
然而，要想安全地这样做，需要理解相关语言的调用协议，以及用go调用C/C++时的栈限制（stack limit）。

##### 4、Go支持哪些IDE？

Go项目并不包含一个定制的IDE，但是它的语言和库的设计，使得很容易去分析它的源码。
因此，许多知名的IDE都很好地支持go，不管是直接支持，还是通过插件。

这些知名的IDE包括，Emacs, Vim, VSCode, Atom, Eclipse, Sublime, IntelliJ（通过一个叫Goland的定制化的variant）。

##### 5、Go支持谷歌的protocol buffer吗？

一个单独的开源项目提供了需要的编译器插件和库。网址是：github.com/golang/protobuf/。

##### 6、我可以把Go的主页翻译成其他语言吗？

当然可以。我们鼓励开发者把Go网站翻译成它们的语言。但如果你要把谷歌的logo或品牌加到你的网站，你需要遵守该指引：www.google.com/permissions/guidelines.html 。

### 三、设计

##### 1、Go是否有runtime？

Go有一个广泛使用的库，叫runtime，它是每个go程序的一部分。
runtime库实现了垃圾回收、并发、栈管理，以及其他go语言的重要特性。
Go语言的runtime类似于C语言的libc，但它更加接近内核（more central to the language ）。

理解这个很重要，不过，Go的runtime并不像java的runtime一样提供虚拟机。
Go程序在成为纯机器码之前被编译（也可以是，JavaScript或WebAssembly等）。
因此，尽管runtime这个词通常用于描述程序运行的虚拟环境，但在go的世界里，runtime只是提供关键服务的库的名字。

##### 2、Unicode标识符是怎么回事？

##### 3、为什么go没有特征X？

每个语言都有其新颖的特性，也会忽略部分人喜爱的特性。
Go的特性主要关注于编程的巧妙，编译的速度，概念的正交，以及一些需要提供的特性，如垃圾回收和并发。
你喜爱的特性可能并没有，因为它不能很好地契合，或者影响了编译速度和设计的简洁，或者它会使得基本的系统模型变得复杂。

如果Go没有特征X困扰了你，请原谅我们，并探索Go具有的特征。
你或许会发现，它们用其他有意思的方式弥补了特征X的缺失。

##### 4、为什么go没有泛型？

泛型也许会在某个时间点加入。我们不认为需要急于这么做，尽管有些程序员认为。

Go语言的目的是写易于维护的服务程序（正如[这篇文章](https://talks.golang.org/2012/splash.article)所说）。(译者注：可以参考这个[ppt](https://talks.golang.org/2012/splash.slide#1))。
它的设计主要集中于可扩展性、可读性和并发性。

多形程序设计（Polymorphic programming）当前并不是Go语言的目标，因而我们舍弃了泛型支持，以便语言更加简洁。

Go语言现在已经成熟了，可以把视野放到泛型编程的一些特性上。不过这里有一些警告。（原话是：However, there remain some caveats）

泛型很方便，但是他们会增加类型系统和运行时的复杂度。
我们目前还没有发现一个设计，能够获得相对于复杂度的等价的收益，不过我们一直在思考。
同时，go内置的map和slice，以及使用empty interface来构建容器，在很多时候能写出像泛型的功能的代码，虽然还不是很顺畅。

我们对这个问题持开放态度。我们可以在[这里](https://github.com/golang/go/issues/15292)看到关于go的泛型的一些不是很成功的设计案例。

##### 5、为什么go没有异常处理？

我们认为，把异常处理和控制流耦合在一起，像 try-catch-finally ，会导致代码难以理解。
这会鼓励程序员把很多常见的错误当作异常，例如打开文件失败。

Go采用了不同的方式。为了简单地处理错误，Go的多返回值的特性，使得它可以很容易地报告错误，而不是定义过多的返回值。
（译者：其实意思就是，go的函数可以定义多个返回值，这样在正确的时候返回正常值，错误的时候返回错误，而不必像C语言那样，要定义一大堆数字来表征不同的错误类型）。

Go有很多内置的函数，在真正出现异常时，它们会发出信号，并尝试恢复。
恢复机制只会在错误发生，并且部分方法的状态异常时执行，这足以处理灾难，并不需要额外的控制结构。
如果使用得好的话，可以让错误处理的代码非常简洁。

可以从[这篇文章](https://blog.golang.org/defer-panic-and-recover)了解defer、pania和recover的更多细节。
另外，[这篇文章](https://blog.golang.org/errors-are-values)介绍了如何清晰地在Go程序里处理错误，因为errors其实是值，因而Go的强大功能可以对此进行错误处理。

##### 6、为什么go没有断言？
Go不支持断言。毫无疑问，使用断言是很方便的，但我们的经验是，程序员会过度依赖断言，导致不会去思考正确的错误处理和报告方式。
正确的错误处理意思是，服务应该尽量地执行，而不是在非致命的错误就崩溃。
正确的错误报告意思是，具有指引性地报告错误，以避免程序员从繁杂的错误堆栈中查找信息。
准确地呈现错误是很重要的，尤其对于那些不熟悉代码的程序员。

我们理解这是一个争议的焦点。在Go语言及它的库函数中，有很多跟现代实践不同的地方，这单纯只是因为，我们认为有时应该尝试一种新的方式。

##### 7、为什么要用CSP的思想来构建并发。
并发和多线程编程一直以来都被认为是有难度的。
我们认为这部分归因于复杂的设计，如:[pthread](https://en.wikipedia.org/wiki/POSIX_Threads)，
另一部分归因于过分强调底层的细节，例如： 锁、条件变量（condition variable）和内存屏蔽（memory barrier）等。
上层的接口可以使得代码更加简单，即便它们也有锁和类似的底层概念。

一个最成功的提供高层次语言支持的并发模型来自于Hoare的CSP（Communicating Sequential Processes）。
Occam和Erlang是两个知名的从CSP衍生出来的语言。
Go的并发原语来自于CSP家族的不同分支，其主要贡献在于把channel做为第一类对象（first class object）。
在几个早期语言的实践经验表明，CSP模型较好地契合于过程式语言框架（procedural language framework）。

##### 8、为什么用goroutine而不是线程？

一个原因是goroutine使得并发更容易使用。
它们思想已经存在一段时间了，就是在一组线程中多路复用，相互独立地执行函数（即：coroutine）。
当一个coroutine阻塞时，如系统调用阻塞，则run-time会把同样操作系统该线程上的其他coroutine切换到一个不同的可运行的线程，这样它就不会阻塞。
这个过程对程序员来说是不感知的，这是关键。结果是，调用goroutine的开销很小，它们只在栈的内存上有一点开销，通常是几KB。


为了使栈空间更小，go的run-time使用了可变的有边界的栈。
一个新建的goroutine通常分配几KB，这一般都够用了。
如果不够的话，run-time会自动增加用于存储栈的空间，使得goroutine有足够可用的空间。
每次函数调用将产生3个CPU的微指令的开销。实践中，可以在同一个地址空间创建数十万个goroutine。
如果goroutine是线程，系统内存在比这个更少数量的情况下就耗尽了。

##### 9、为什么map没有定义成原子操作？

经过长时间的讨论之后，我们决定map的典型使用在多个goroutine情况下，不强制要求安全存取，这些情况是指，map可能是同步了的大数据结构或计算的一部分。
因而，如果要求所有的map操作都要锁控制，会降低大多数程序的速度，而且对安全性也没有较大帮助。
这不是一个简单的决定，因为这意味着不可控制的map访问会搞垮整个程序。

Go语言本身并不阻碍原子化map的更新。如果需要的化，例如执行一个不信任的程序，在实现上可以互锁map的访问。
（原话是，The language does not preclude atomic map updates. When required, such as when hosting an untrusted program, the implementation could interlock map access。
大概理解是说，虽然map本身不提供原子操作，但如果实际需要的话，实现的时候，可以在访问map时加上锁控制）。

map的访问只有在更新出现时才会不安全。
只要所有的goroutine都是在读，包括查询map中的元素、for range循环等，只要不是分配元素或者是删除这样改变map的操作，那么就可以安全地并发访问map，而不需要同步。

为了正确使用map，有些语言的实现会有特殊的检查，它在run time状态如果发现map被并发执行不安全地修改时，会自动地报告。

##### 10、你们会接受我对go语言的改进意见吗？

很多人会就go语言提出改进意见--邮箱里有大量的讨论纪录--但实际上很少意见会被接受。

尽管Go是一个开源项目，但语言和库函数还是受兼容性承诺的，以避免一些改变会影响现有的程序，至少在源码级别。
如果你的建议违反了Go 1.x的规范，我们是不会采纳该想法的，尽管它很有价值。
未来Go的主要release版本可能不会兼容Go 1.x，但其实对这个问题的讨论只停留在开始阶段，有一定是肯定的，这样的不兼容是很少的。
另外，兼容承诺会鼓励我们为老的程序提供一个随着环境变化而自动升级的路径。

即便你的提议符合Go 1.x的兼容性，它也不一定满足go的设计宗旨。
文章[Go at Google](https://talks.golang.org/2012/splash.article)阐述了Go的起源和它设计背后的动机（motivation）。


### 四、类型

##### 1、Go是一个面向对象的语言吗？

是，也不是。尽管Go有类型和方法可以允许面向对象的编程风格，但它没有类型的层级。
Go的interface概念提供了一种不同的方式，我们相信，它容易使用，甚至在某些方面更通用。
Go还可以把一个类型嵌入到另一个类型，以此来类似（但不等同）于一个子类。
此外，Go的方法比C++和Java更加通用，它可以为任何数据类型定义方法，即便是int这样的内建类型，而不仅局限于结构（或者类）。

由于go没有类型层级（type hierarchy），使得它比C++或者Java更加轻量。

##### 2、如何实现多态（dynamic dispatch of methods）？

唯一实现多态的方式是通过接口。基于结构或其他具体类型的方法总是静态解析的。

##### 3、为什么没有类型的继承？

大多数熟知的面向对象语言，包含了大量关于类型关系，以及关系可以派生的的讨论。而Go采用了一种不同的方式。

相比于其他语言要求程序员提前声明两个类型的关系，在Go里，只要一个类型只要实现了一个接口的所有方法，它就自动实现了该接口。
除了减少声明（reducing the bookkeeping），它还有一个实际的好处。
这个类型可以一次满足许多接口，而没有传统的多重继承的复杂性。
接口可以是非常轻量的，一个只有1或0个方法的接口就可以表达一个有用的概念。
一个接口可以在有新的思路或者测试的时候添加，而不影响原先的类型。
因为类型和接口之间并没有显示的关系，也不存在类型层级要去管理或讨论。

通过这些思路，可以构建一些类似类型安全的unix管道的东西。
例如，看fmt.Fprintf如何格式化输出任何数据，而不仅仅是文件；
或者是bufio包中如何从文件I/O中分离；又或者image如何生成压缩图片文件。
所有这些想法来自于：单一接口（io.Writer）代表单一方法（Write）。
这还只是表面的影响。Go的接口对整个程序的构建产生了深远的影响。

这需要一定时间去适应，但这种隐式的类型依赖是Go最精髓的地方。

##### 4、为什么len是一个函数而不是一个方法？

我们讨论过这个问题，但最终还是把len实现为函数，这个不会使得Go的类型体系中，interface是基础类型这个问题复杂化。

##### 5、为什么Go不支持重载方法或操作符？

如果不需要匹配类型，方法的调用会非常简单。
在其他语言的使用经验告诉我们，有很多同名字但不同signature的方法有时很有用，但在实践中，它会引起困惑，而且很脆弱。
只通过名字匹配，而且要求类型一致性，是Go的类型系统设计时，为求简洁作出的决策。

对于操作符重载，它看起来便利，但实际上没有必要。（原话是， it seems more a convenience than an absolute requirement）。
而且，如果没有它，反而会更简单。

##### 6、为什么GO没有"实现"的声明？

Go的类型是通过实现接口的方法来满足一个接口。
这个特性使得接口可以自由地定义和使用，无需修改现有代码。
这使得类型结构化（structural typing），有助于关注点分离，提高代码复用性，而且在开发时，更容易构建代码合并的模式。
接口的语义是GO语言敏捷、轻量化的原因。

##### 7、我如何保证我的类型满足一个接口？

你可以让编译器帮助你检查类型T实现了接口I，只要把零值分配给T或者是指向T的指针，例如：

```go
type T struct{}
var _ I = T{}       // Verify that T implements I.
var _ I = (*T)(nil) // Verify that *T implements I.
```

如果T（或者*T）没有实现接口I，它会在编译的时候就发现这个错误。

如果你希望接口的使用者显示地声明他们实现了接口，你可以把一个名字有含义的方法加入到接口的方法集合，例如：

```go
type Fooer interface {
    Foo()
    ImplementsFooer()
}
```

类型必须实现ImplementsFooer来成为Fooer，并在godoc中注明此次实现。

```go
type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}
```

大多数代码没有用到这些限制，因为他们限制了interface思想的应用。
有时，尽管他们可以用于解决相似接口的歧义性。

##### 8、为什么类型T不满足Equal接口？

考虑一个简单的接口表示一个对象可以将其自己和另一个值做对比：

```go
type Equaler interface {
    Equal(Equaler) bool
}
```

以及类型T：

```go
type T int
func (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler
```

与类似多态类型系统的情况不同，T并没有实现Equaler。
T.Equal的实参类型是T，而不是要求的类型Equaler。

在Go里，类型系统并没有推导Equal的实参；这是程序员的责任去实现Equaler，正如类型T2所阐述的那样：

```go
type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler
```

在Go中，任何类型满足只要实现了Equaler接口，就可以做为实参传递到T2.Equal，因而在运行时，我们需要校验实参是类型T2。
一些语言在编译时候就保证了一致性。

```go
type Opener interface {
   Open() Reader
}

func (t T3) Open() *os.File
```

在Go里，T3没有实现接口Opener，尽管可能对其他语言来说是实现了的。

在这些case中，尽管Go的类型系统为程序员做的不多，但缺少子类型的机制，使得实现接口的规则变得简单：看函数的名字和signature是否跟接口一样。
Go的规则很容易高效地实现。我们认为这些好处可以弥补在自动类型推导上的缺失。
Go是否有一天会采用多态类型的形式，我们希望有一种方式可以表达这些例子的想法，并且能做静态检查。

##### 9、如何把[]T转化成[]interface{}

不能直接转换。在语言的规范上并不支持，因为这两种类型在内存中没有相同的表示方式。
它需要单独地把元素拷贝到目标slice。
以下示例把int的slice转化成interface{}的slice：

```go
t := []int{1, 2, 3, 4}
s := make([]interface{}, len(t))
for i, v := range t {
    s[i] = v
}
```

##### 10、如何把[]T1转化成[]T2，如果T1和T2底层的类型是一致的？

代码样例的最后一行编译不过：

```go
type T1 int
type T2 int
var t1 T1
var x = T2(t1) // OK
var st1 []T1
var sx = ([]T2)(st1) // NOT OK
```

在Go里，类型紧密地和方法绑定在一起，也就是说，任何命名的类型都有一个方法集合（即便它可能是空的）。
通用的规则是，你可以改变被转换的类型的名字（因而会导致它的方法集合的改变），但不能改变一个组合类型的元素的名字（以及方法集合）。
Go需要你显式的指定类型的转换。

##### 11、为什么我的nil错误值（nil error value）不等于nil

在底层，interface实现为两个元素（element），类型T和值V。
V是一个具体的值，例如int、struct或指针，但不是interface，它有类型T。
如果我们把值为3的int保存为一个interface，则interface的结果为（T=int,V=3）。
V会被认为是接口的动态值，因为一个给定的接口在程序执行时会有不同值V，当然其对应的类型T也不同。

一个接口只有在T和V都没有被设置的情况下才为nil，也就是T=nil，V没有设置。
尤其是，一个nil的接口，其类型永远是nil。
如果我们把一个*int类型的nil指针保存在一个接口，它的值就是：T=*int，V=nil。
这个接口的值就为non-nil，即便这个接口的V值是nil。 

当一个nil值存在一个接口值，例如返回的error值，就会引起困惑：

```go
func returnsError() error {
	var p *MyError = nil
	if bad() {
		p = ErrBad
	}
	return p // Will always return a non-nil error.
}
```

如果所有环节都正常执行的话，函数会返回一个nil值p，因此返回值是一个error接口（T=*MyError, V=nil）。
这意味着，如果调用者把返回错误和nil做对比，它就会认为它有错误，尽管并不是。
为了返回准确的nil，函数必须显式地返回nil：

```go
func returnsError() error {
	if bad() {
		return ErrBad
	}
	return nil
}
```

返回值最好总是用error类型当作他们的signature，而不是用一个具体的类型，例如*MyError，这样可以保证error可以准确被创建。
例如，os. Open 返回一个error类型，如果它不是nil，它就会是一个具体的类型*os.PathError。

不管什么时候使用接口，这里描述的这种情况总是有效的。
只要牢记，只要任何具体的值保存在接口中，接口的值就不会是nil。
要获得更多信息，可以参考[这篇文章](https://blog.golang.org/laws-of-reflection)。

##### 12、为什么不像C一样，有untagged union?

untagged union会破坏Go的内存安全保证。

##### 13、为什么Go没有可变的类型？

可变类型，即algebraic type，提供了一个方式来表征一个值只可能是一个集合的类型。
一个常见的例子是，系统编程会明确指出错误是网络错误，安全错误，或者其他错误，它会验证错误的类型，允许调用者区分问题的来源。
另一个例子是语法树，它的每个节点都可以有不同类型：定义、语句、赋值等等。

我们考虑在go中加入可变类型，但经过讨论后，我们决定不引入该特性，因为他们会跟接口在一些地方重叠而导致困惑。
如果一个可变类型中的一个元素是接口，会发生什么呢？

另外，可变类型想表达的思想已经被go语言涵盖了。
error是一个很好的例子，它使用接口的值来保存错误，用类型的值来区分类型。
语法树也是一个例子，只是解法并不是那么优美。

##### 14、为什么go没有covariant result types？

（注，covariant result type是值在子类重写父类方法时，可以改变方法的返回类型）

covariant result types意味着像这样的接口，
 
```go
type Copyable interface {
	Copy() interface{}
}
```

会被该方法实现

```go
func (v Value) Copy() Value
```

因为Value实现了空的接口。
在Go的方法里，类型必须精确匹配，所以Value没有实现Copyable。Go把一个类型要做什么（即它的方法）从类型的实现中分离出来。
如果两个方法返回了不同的类型，那么他们就不是在做一样的事情。
程序员通常想要covariant result type，主要是要想通过接口来表达类型层级（type hierarchy ）。
在Go里面，这样分离接口和实现其实更加自然。

### 五、值

##### 1、为什么go没有提供隐式的类型转换。

在C语言里，它提供了自动类型转换，但由此带来的麻烦已经超过了它带来的便利。
它何时代表为无符号类型？它的最大值是多少？它是否溢出？它的结果是否依赖于机器？
此外，这还增加了编译器的复杂度；"常见的数值转换"并不容易实现，而且不同架构之间一致性较差。
因此，我们让这个问题更加清晰和直接，虽然这样会导致在代码里要显式地进行转换。

另一个相关的细节是，go跟C不一样，在go里，int和int64是不同的类型，即便int它可以是64位的。
int类型更加通用，但如果你很在乎它有多少位，go鼓励你显式地使用它。

##### 2、Go里面的常量是如何工作的？

尽管Go对不同类型数值的转换非常严格，但它对常量的支持却灵活得多。
像23，3.1415,Math.Pi这样的常量会分配合理的数值存储空间，而不会有任何的溢出和精度损失。
例如像math.Pi在源码中会占63个空间，而go里面的常量能够提供比float64更高的精度。
只有当它被分配给一个变量--即在程序中的内存--它才会变成一个"可计算"的数字，而有像浮点数一样的属性和精度。

同时，由于它们只是数值，而不是类型值（type value），使得在go里，常量会比变量更加灵活，它可以避免一些类型转换的规则。
例如，这个例子：

```go
sqrt2 := math.Sqrt(2)
```

对编译器来说，它不会有问题，因为有理数（ideal number？）可以安全、准确地转化为float64类型，做为math.Sqrt的参数。

[博客](https://blog.golang.org/constants)提供了更多关于常量的细节。

##### 3、为什么map是内置的？

它的理由跟string类型是内置的一样：它们是都是一种强大的数据结构类型，在语法层面进行支持实现，可以使得程序更加友好。
我们相信go对map的实现非常地健壮，它可以大多数主要的用途。
如果一个定制化的实现能很好地应用于特定的应用，我们可以写一个，但是它语法层面并不是那么方便；因而，这是一个合理的折中（trade-off）。

##### 4、为什么map不能把slice做为key？

map的查找需要实现等值操作符（equality operator，也就是重载=），而这个在slice里并没有实现。
不实现的原因是，相等在slice不好定义；它们会有很多考量，包括对浅层和深层的比较、指针和值的对比、如何处理嵌套类型等等。
我们或许会重新审视这个问题--实现slice的相等不会影响任何现在的程序，不过在没有明确slice的相等的定义时，最简便的方法是先搁置它。

在Go 1.x的版本里，定义了struct和array的相等，所以这些类型可以作为map的key。而slice的相等还没有定义。

##### 5、为什么map、slice、channel是引用，而array是值？
这是个漫长的故事。最早的时候，map和channel在语法上是指针，因而不能声明，或者使用非指针的实例。
同时，我们也在苦苦思考array如何工作。最后，我们认为把指针和值分离开会使得go语言很难使用。
于是把这些类型改变为对关联的共享数据结构的引用，这样就很好解决了这些问题。
这样的改变给go语言带来了一些令人遗憾的复杂度，但这样大大提高了可用性：go成为了一个富有生产力、使用方便的编程语言。

### 六、代码

##### 1、库函数的文档在哪？
有一个用go写的程序godoc，它可以从源代码中提取包的文档，并提供一个web服务页面，可以访问它的声明、文件等。
其中一个例子就是(golang.org/pkg/)[golang.org/pkg/]。

一个godoc的样例可以提供丰富的可交互的静态代码分析，具体细节可以看(这里)[https://golang.org/lib/godoc/analysis/help.html].

为了更好地从命令行访问文档，go的工具集的[doc子命令](https://golang.org/pkg/cmd/go/#hdr-Show_documentation_for_package_or_symbol)提供了一个文本化的接口获得相应的信息。

##### 2、是否有go的编程风格指引？

没有显式的风格指引，不过确实有"go风格"这种东西。

go已经有一些惯例来指导命名、代码布局以及文件组织等。[Effective Go](https://golang.org/doc/effective_go.html)也有这些方面的建议。
更直接的，gofmt程序可以强制遵守代码布局的规则；它替代了常规的可解释的做什么&不做什么的概要。
（我理解，意思就是说，之前都是靠纲领说明做什么和不做什么，而gofmt可以直接自动化帮你做这些）
所有仓库的go代码，以及开源世界的大部分代码，都是经过gofmt运行的。

(Go Code Review Comments)[https://github.com/golang/go/wiki/CodeReviewComments]是一系列关于go编程规范的短文，它们写了一些经常被程序员忽略的细节。
这是一个方便技术人员做code review的参考文献。

##### 3、我如何提交补丁到go的库？

go的源代码在仓库的src路径下。如果你需要做大的改动，请先在mailing list上进行讨论。

还可以通过(这篇文档)[https://golang.org/doc/contribute.html]获得更多信息。

##### 4、为什么"go get"在复制仓库的时候用的是HTTPS？

公司通常会限制outgoing traffic，只使用80端口(HTTP)和443端口(HTTPS)，而阻止其他TCP端口，包括9418端口(git)和22端口(SSH)。
当使用HTTPS而不是HTTP时，git会默认强制进行可行性校验，这样避免中间人攻击（man-in-the-middle）。
出于安全考量，go get命令使用了HTTPS。

Git可以配置对HTTPS授权，或者用SSH替代HTTPS。要是授权HTTPS，可以在 $HOME/.netrc 加一条命令：

```go
machine github.com login USERNAME password APIKEY
```

对GitHub账号，其密码可以是(个人访问token)[https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line]。

Git还可以配置使用SSH替代HTTPS，只要URL匹配命中前缀。例如，在  ~/.gitconfig 中写入以下行：

```go
[url "ssh://git@github.com/"]
	insteadOf = https://github.com/
```

##### 5、如何使用"go get"来管理包的版本？

### 七、指针和分配

##### 1、什么时候函数的参数是传值的？

正如所有的C家族的语言，任何东西在go里都是传值的。
也就是说，一个函数总是获得传入的东西的副本，就好像有一个分配的语句把值分配给参数。
例如，传递一个int，它就会复制一个int，传递一个指针，它就会复制一个指针--但不是这个指针指向的值。

map和slice比较像指针：它们都包含了指向底层map或者slice数据的指针。
复制一个map或者slice并不会复制它们指向的数据。
复制接口会也会同时拷贝接口的value值（之前说过，接口由两个组成，类型和值）。
如果接口值是一个结构，那么它同时也会复制这个结构。 
如果接口值是一个指针，那么它会复制指针，但不会复制指针指向的数据。

注意，我们只是在讨论操作符的语义。实际的实现可能会使用优化技术来避免拷贝，当然，这些优化并不会改变语义。

##### 2、何时使用指向接口的指针？

最好永远不要。指向接口的指针会引起很罕见而奇怪的问题，如它会隐藏接口的类型，而在之后才会计算。

一个很常见的错误是，函数的入参是接口，而且传递进去一个指向接口的指针。
编译器可能会警告这个错误，但即便这样，还是会引起困惑，因为有时指针是有必要满足接口的。
它的底层原则是，尽管一个指向具体类型的指针满足一个接口，但是一个指向接口的指针是不满足一个接口的。

考虑一个变量的声明：

```go
var w io.Writer
```

打印函数fmt.Fprintf的第一个实参是实现 io.Writer 的值--有时它实现了传统的Write方法。
因此，我们可以写成：

```go
fmt.Fprintf(w, "hello, world\n")
```

如果我们传递w的地址，程序则编译不通过。

```go 
fmt.Fprintf(&w, "hello, world\n") // Compile-time error.
```

有一个例外是，任何值（包括指向接口的指针）都可以分配一个空的接口类型（interface{}）。
即便是这样，指向接口的指针基本上是一个错误，因为它会引起困惑。

##### 3、我应该把方法定义在值上还是指针上？

```go
func (s *MyStruct) pointerMethod() { } // method on pointer
func (s MyStruct)  valueMethod()   { } // method on value
```

对于不熟悉指针的程序员，对这两个例子会感到很困惑，但其实它很简单。
当定义一个类型的方法时，它的receiver（也就是上面例子的s）可以理解为方法的实参。
那么把receiver定义为值还是指针取决于你的函数的实参希望是值还是指针。
当然，这里会有很多考量。

首先是，方法是否需要修改receiver？如果是的话，则receiver必须是指针。
（slice和map是引用，因而会有一些细微的地方，但如果是在方法里改变slice的长度，则receiver必须是指针）
在上面的例子中，如果pointerMethod修改了域s的值，则调用者会感知到改变，但valueMethod里，则是实参的拷贝（也就是传值调用），因而函数内的改变对调用者是没有影响的。

另一方面，Java方法的receiver总是指针，尽管他们的指针在一定程度上是隐藏的。
Go的值的receiver是比较独特的。

另一个考量是一致性。如果一些类型的方法必须有指针的receiver，那么其余的也必须要这样，因而他们的方法集是一致的。

对像一些基本的类型，如slice和小的struct，值的receiver的代价非常小，因而除非语法要求必须是指针，否则值的receiver是非常有效和清晰的。

##### 4、new和make的区别

一句话：new分配内存，而make用于初始化slice、map和channel类型。

更多的细节在Effective Go。

##### 5、int类型的size在64位的机器是多少？

int和uint的size取决于具体实现（implementation-specific），但他们在给定平台上是一样的。
为了使用方便，代码如果依赖与具体的size，可以明确地使用像int64这样的类型。
通常，32位的机器上，编译器默认使用32位整型，而64位机器上，则使用64位整型。（这个结论并不总是正确）

另一方面，浮点和复杂类型总是尺寸一定的，因为开发者在使用的时候，需要知道浮点的精确度。
因而，对于浮点的常量，它的类型是float64，比如 foo:=3.0， 则是声明一个float64的变量foo。
而如果要用常量来初始化一个float32类型，则需要显式地声明：

```go
var foo float32 = 3.0
```

另一种方法是，进行类型的转换，例如：foo := float32(3.0)。

##### 6、如何知道一个变量是分配在堆上还是栈上？

一个正确的观点是，你不需要知道。Go的每一个变量，只要它被引用到，它就会一直存在。
存储位置取决于它的具体实现，而跟语法无关。

当然，存储位置对写高效的程序是有影响的。如果可能的话，Go的编译器会把变量分配在函数的stack frame中。
不过，编译器没法保证这个变量在函数返回之后不会被引用，于是编译器会把变量放在垃圾回收的对上来避免悬空指针（dangling pointer）。
此外，如果本地的变量非常大，它放在堆比放在栈更加合理。

在当前的编译器中，如果一个变量的地址被使用（if a variable has its address taken），它就会成为放在堆的变量的候选。
当然，如果逃逸分析（escape analysis）能识别出这个变量在函数返回时不会使用，那么它就可以在栈中。

##### 7、为什么Go进程使用这么多虚拟内存？

Go的内存分配器会保留一个大的虚拟内存。虚拟内存对特定的go进程是局部的；保存器不会夺取其他进程的内存。

要找到Go进程实际分配的内存，在unix系统中可以使用top，查看RES列（Linux）或者RSIZE列（macOS）。


### 八、并发

##### 1、什么操作是原子性？什么是关于锁？

关于Go的原子性操作可以在(文档中)[https://golang.org/ref/mem]找到。

底层的同步机制和原子原语可以在sync和sync/atomic包里找到。
这里包对简单的任务很好用，例如：引用统计、小范围的互斥。

对于高阶（higher-level）的操作，例如并发服务之间的协同，高阶的技术会得到更好的代码，而go是通过goroutine和channel来达到目的。
例如，你可以组织你的程序，使得任务时候只有一个goroutine访问一块特定的数据。
这个方法在[go proverb](https://www.youtube.com/watch?v=PAAkCSZUG1c)里进行了总结。

不要通过贡献内存来进行通信，而是通过通信来共享内存。

可以看[代码走读](https://golang.org/doc/codewalk/sharemem/)和[相关文档](https://blog.golang.org/share-memory-by-communicating)获得更多细节。

大型的并发程序可以从这些工具集中获得启发。

##### 2、为什么更多的CPU没有让我的程序更快？

一个程序是否在多CPU下跑得更快，取决于它要解决什么样的问题。
Go提供了并发的原语，例如goroutine和channel，但是并发只有在底层的实际问题是真正的并行时才会并行的。
如果底层的实际问题本身就是串行执行的，那么就不能通过增加CPU来提高速度，除非能把问题分解成多个部分来进行并行，这样有时会获得巨大的提高。

有时增加更多的CPU会降低程序的性能。在实践中，程序花费更多的时间在同步和通信，而不是做有用的计算，会降低性能。
这是因为在线程之间传递数据会涉及到上下文切换，这样会耗费大量性能，而且性能损耗会随着CPU增加而增多。
例如这个[示例](https://golang.org/ref/spec#An_example_package),它并没有显著的并行，因为它启动了太多的goroutine；增加更多的线程（CPU）会降低它的性能而不是提高。

更多的细节可以参考[这篇演讲](https://blog.golang.org/concurrency-is-not-parallelism)。 

##### 3、如何控制CPU的数量？

允许同时执行goroutine的CPU的数量是由shell的环境变量GOMAXPROCS来控制的，它的默认值是可用的核的数量。
天生适合并行的程序在多CPU的机器上会默认并行。
要改变使用的并行CPU的数量，需要设置环境变量，或者用runtime包里的函数来配置run-time的支持来使用不同的线程数。
设置为1可以避免使用真正的并行，强制goroutine按顺序执行。

runtime可以分配比GOMAXPROCS更多的线程来提供多I/O请求服务。
GOMAXPROCS只影响一次有多少个goroutine可以同时执行；任意多的值会导致在系统调用阻塞。

Go的goroutine调度并不如它所期待的那么好，尽管它比之前已经改善很多了。
在未来，它会对它使用OS线程进行优化。
而现在，如果有性能的问题，设置GOMAXPROCS可能会有帮助。

##### 4、为什么goroutine没有ID？

goroutine没有名字；他们只是匿名的工作协程。他们不对开发者暴露唯一标识、名字或数据结构等信息。
一些人对次感到不解，期望go的语法返回一些信息，使得可以访问和控制goroutine。

goroutine是匿名的本质的原因是：当编写并行的代码时，整个go语言都是可用的。
反过来，如果线程和goroutine被命名的话，就会限制一个库对它们的使用。

这是对这个问题的一个解释。一旦用户命名一个goroutine，并围绕它建模，它就会变得特别，用户就会倾向于把所有的计算都跟这个goroutine关联起来，而不会去考虑，如何使用多个共享的goroutine来进行处理。
如果net/http包关联了goroutine的per-request状态，客户端在服务某个请求的时候，就没办法使用更多的goroutine。

另外，像图形系统的一些库，它们要求所有的处理都在"主线程"，这时，如果要在一门并发的语言上实践，会发现有很多困难和限制。
存在的特殊的线程或goroutine会要求程序员distort程序来避免crash，或者是其他错误线程不经意导致的其他错误。

对于一些场景，特定的goroutine真正的很特别，go则提供了一些特性，如channel用于跟它交互。


### 九、函数和方法

##### 1、为什么T和*T有不同的方法集？

正如go的[规范文档](https://golang.org/ref/spec#Types)所说，类型T的方法集包含了receiver类型T的所有方法，而*T则包含了receiver类型T和*T的所有方法。
这就意味这*T的方法集涵盖了T，但反过来不是。

之所以要这样做是因为，如果一个接口值是指针*T，则方法调用可以通过解引用（dereference）来获得值，但如果一个接口值是类型T，那就没有一个安全的方式获得一个指针。
（这样做是为了允许一个方法在接口内修改值的内容，而go的规范上是不允许的）。

同样的一个例子是，编译器会把值的地址传到方法，如果方法修改了值，则对调用者会有丢失。
例如，如果bytes.Buffer的Write方法用值的receiver而不是指针receiver，像这样：

```go
var buf bytes.Buffer
io.Copy(buf, os.Stdin)
```

它就会把标准输入流拷贝到buf的拷贝中，而不是buf本身。这不是我们期望的行为。

##### 2、当闭包以goroutine来运行，会怎么样？

一些人对使用闭包并行会有疑惑。像以下的例子：

```go
func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}
```

可能你会认为输出结果是a，b，c，这是不对的。而你看到的结果应该是c，c，c。
这是因为每次loop迭代都使用了变量v的相同实例，因此每个闭包共享了同样的值。
当闭包运行时，它会在fmt.Println运行时打印v的值，但是v是在goroutine启动是就修改了。
要避免这样的问题，可以使用go vet。

要把当前v的值跟每个闭包绑定起来，必须在每次迭代，修改loop来创建新的变量。
一个方式是传递变量作为实参到闭包：

```go
for _, v := range values {
        go func(u string) {
            fmt.Println(u)
            done <- true
        }(v)
    }
```

在这个例子中，v的值作为实参传到匿名函数，因而可以使用函数内的变量u来访问到它。

另一个简单的方式就是创建一个新的变量，使用定义的方式可能看起来奇怪，但是可行的：

```go
for _, v := range values {
        v := v // create a new 'v'.
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }
```

go语言的这个特性--不在每次迭代的时候定义新的变量，现在回想起来可能是个错误。
它可能会在之后的版本解决，但为了兼容性，在Go 1.x版本不会做任何改变。

### 十、控制流

##### 1、为什么go没有 ?: 操作符 ？ 

在go里没有三元的测试操作。你可以用以下代码来达到相同的结果：

```go
if expr {
    n = trueVal
} else {
    n = falseVal
}
```

go里没有?:的原因是，go的设计者发现这个操作符经常用于复杂的表达式。
而if-else的格式，虽然比较长，但是毫无疑问是很清晰的。
一门语言只需要单条件控制流结构（one conditional control flow construct）。

### 十一、包和测试

##### 1、如何创建多文件的包？

所有包的源文件都放在一个路径里。源文件可以引到不同文件的项目；它不需要前置声明（forward declaration）或者是头文件。

包的所有文件会一起编译和测试，就像是一个文件一样，而不会分成多个文件。

##### 2、如何写单元测试？

在包的目录创建一个_test.go文件，在文件里引入"testing"包，并像这样写函数：

```go
func TestFoo(t *testing.T) {
    ...
}
```

在该文件夹里执行 go test。 这个脚本会找到 Test 函数，编译成测试的二进制文件，并运行。

可以通过[test包](https://golang.org/pkg/testing/)和[go test命令](https://golang.org/cmd/go/#hdr-Test_packages)获得更多信息。

##### 3、我最喜欢的测试的helper函数去哪儿了？

Go的标准test包使得编写单元测试变得简单，但它缺少其他语言提供的测试框架，例如断言函数。
这篇文档的前面部分解释过为什么go没有断言，这些理由对这个问题同样使用。
合适的错误处理使得错误发生时，其他测试用例可以继续进行，这样调试人员可以获得错误的完整快照。
对于isPrime这个测试用例来说，报告2、3、5、7的测试得到了错误结果，比仅仅报告2错误而后放弃后续用例的运营更好。
触发测试用例错误的程序员获取并不熟悉代码。
花在写好的错误信息的时间会在测试错误出现时获得回报。

一个相关的观点是，测试框架倾向于开发他们自己的mini-language，包括条件、控制、打印等机制，但go已经有了这些，为何还要重复造轮子？
我们更愿意在go里写测试；这不需要额外学习语音，而且这个方法使得测试更加直接、容易理解。

如果写好的错误提示会导致更多重复而繁杂的工作，测试最好能做到table-driver，即迭代运行写在数据结构里的输入和输出。
写好的测试用例和错误提示可以复用到其他更多的测试用例上。
标准go库有很多展示用例，例如[fmt包的测试](https://golang.org/src/fmt/fmt_test.go)。

##### 4、为什么标准库里没有某个特性X？

标准库的目的是提供运行时、操作系统链接、以及go开发的关键功能，例如标准化的IO和网络等。
它还包括web开发的关键技术，如加密、标准格式（如：JSON、HTTP、XML等）。

它没有准则定义什么应该在标准库里，因为在很长的时间里，它仅仅只是go的库。
不过，今天已经有明确的标准决定什么应该加到库里。

加入到标准库是很少的，而且它的门槛很高。
代码加入到标准库需要大量的维护成本，它还要遵守go的[兼容协议](https://golang.org/doc/go1compat)，以及go的[版本发布进度](https://github.com/golang/go/wiki/Go-Release-Cycle),使得修复的bug能够快速对用户生效。

大多数新的代码应该在标准库之外发布，并可以通过go tool获取。
这些代码有自己的维护者、发布周期和兼容保证。
用户可以在godoc.org上找到这些包，并阅读其文档。

尽管一些代码在标准库中，但实际上并不属于标准库，例如log/syslog，但我们还会在1.x版本里继续维护，因为我们承诺过对Go 1的支持。
但我们新的代码待在其他的地方（个人理解，就是你可以有，但不在标准库）。

### 十二、实现

##### 1、构建编译器时，用了哪些编译技术？

有几个产品用于编译go，还有一些用户不同平台。

默认的编译器gc，跟go一起分发，它用于支持go命令。
gc最早是C写成的，因为引导装入程序是很困难的--你需要一个go的编译器来建立go的环境。
不过事物总是在进步的，到了go 1.5版本，它的编译器就成了go程序。
编译器从C到go使用了自动翻译工具(automatic translation tool),在[设计文档](https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8/edit)和[演讲](https://talks.golang.org/2015/gogo.slide#1)中有详尽描述。
因此，编译器现在是"self-hosting"，也就是说我们需要面对引导装入程序(bootstrapping)的问题
解决方法是，提前安装了go的工作环境，就跟安装C的工作环境一样。
如何从源码搭建go的开发环境可以参考[这个](https://golang.org/doc/install/source)。

gc用go编写的，它用递归下降语法分析器(recursive descent parser )和定制化的加载器来生成ELF/Mach-O/PE二进制，加载器也是用go写成的，不过是基于Plan 9的。

最初的时候，我们考虑用LLVM，但它太大了，且慢，不能满足我们的性能目标。
现在追溯起来，还有一个重要的原因，如果一开始用LLVM，会更难引入ABI和其他变化（如栈管理），而这些特性都是go要求的，而不在标准C里。
不过，现在已经有相互适配的[新的LLVM](https://go.googlesource.com/gollvm/)。

gccgo编译器的前端是用C++编写的递归下降语法分析器，而后端是标准的GCC。

Go在实现go编译器方面证明了它是一门很好的语言，尽管在开始这并不是它的目标。
起初它不是self-hosting，这使得go关注于它最初的应用场景，即网络服务。
在我们决定go应该能自我编译，我们开始编译器构建，这是一个有价值的目标，但不是我们最初的目标。

尽管gc还没有用到这些，不过lexer和parse都可以在[包](https://golang.org/pkg/go/)找到，此外还有一个[类型检验](https://golang.org/pkg/go/types/).

##### 2、runtime如何支持实现？

同样是因为bootstrapping的问题，run-time最初的代码是用C写成的，但它现在翻译成了go语言。
Gccgo的runtime主要靠glibc支持。gccgo编译器使用了一种叫分割栈(segmented stacks)的技术来实现goroutine，
Gollvm与此类似，它基于相应的LLVM结构来构建的。

##### 3、为何我的普通程序有这么大的二进制文件？

gc的连接器会默认创建静态连接的二进制。所有的go二进制都会包含在go的运行时，与run-time类型信息一起进行动态类型校验、反射，甚至在panic时进行栈的回溯。

一个C的hello world程序，在linux上用gcc编译和静态链接大概是750KB，包括实现printf。
一个等价的go程序用fmt.Printf则需要几MB，但它包含了强大的运行时支持、类型、以及debug信息。

用gc编译的go程序可以加入-ldflags=-w标识来关闭DWARF生成，从而从二进制移除编译信息，而不会影响函数的功能。
这样会显著地减少二进制的大小。

##### 4、如何停止对没有使用的变量/包的警告？

没有使用的变量的存在会提示bug，因为没有使用的import会减慢编译速度，而随着代码的累积，这会成为程序的必要部分。
出于这个原因考虑，go编译器会拒绝没有使用的变量和引入，短期内它会带来不便，但长期来看，它会提高构建的速度，以及使得程序更加清晰。

不过，写代码的时候，还是会暂时遇到这些问题，要在编译之前把这些代码移除，这确实很烦人。

一些人要求提供关闭编译器检测的选项，或者至少减少这些告警。
这些相关并没有加入，编译器的选项不应该影响语言的语法，因为go的编译器不会提示警告，只有错误才会停止编译。

Go编译没有警告主要出于两点考虑。第一点是，既然觉得有必要提示，那么就应该在代码里修复它（反过来，如果不必要在代码里修复，那就不需要提出）；
第二点是，要编译器生成警告信息，会鼓励其警告一些不太重要的问题，这提示太多问题，使得真正需要修复的错误被忽略。

这个问题其实很容易解决，在开发的时候，用空白占位符来保留不使用的变量/包。

```go
import "unused"

// This declaration marks the import as used by referencing an
// item from the package.
var _ = unused.Item  // TODO: Delete before committing!

func main() {
    debugData := debug.Profile()
    _ = debugData // Used only during debugging.
    ....
}
```

现在，很多开发者都使用[goimports工具](https://godoc.org/golang.org/x/tools/cmd/goimports)自动修改go文件来正确地引入包。
这个工具很容易连接到大多数编辑器，并在写go文件时会自动运行。

##### 5、为什么我的杀毒软件会认为go的编译文件被感染了？

这个情况经常出现，尤其是在windows的机器上，而且大多数情况下都是误判。
商用的病毒扫描程序通常对go二进制的结构感到困惑，相比其他语言，它们很少看到编译的文件是这样的。

如果你刚装了go distribution，而系统报告它是病毒，这显然是个错误。
你可以把自己下载的文件跟[页面](https://golang.org/dl/)的文件的校验值进行对比。

任何时候，只要你确认是一个错误，你就可以把错误报告给你的杀毒引擎扫描仪。
也许，最后它能学会理解go的程序。

##### 
### 十三、性能
1、为什么go在benchmark的某些指标表现不好？ 


### 十四、跟C语言不同之处

##### 1、为什么go的语法跟C有这么多不同？

除了声明的语法，这两个语言的语法差别并不大。（原话是，Other than declaration syntax, the differences are not major and stem from two desires.）
首先，语法应该轻量，不要有太多强制的关键字、不能重复而晦涩。
其次，语法应该应该易于分析，而且不需要符号表来做语法分析。
这使得更容易构建像调试器、依赖分析器、自动文本提取、IDE插件等工具。
C和它的衍生语言在这方面都做的不好。

##### 2、为什么声明向后兼容？

如果你习惯用C，它们只会向后兼容。 
在C里面，一个变量被声明，就像一个表达式表明它的类型，这是一个好主意；
不过类型和表达语法很难很好地融合，这样结果会让人困惑，例如函数指针。
go大多数情况下把表达式和类型语法做了区分，这简化了很多事情（用前缀符号*表达指针是该规则的一个例外）。

在C语言，如果是这样声明：

```go
int* a, b;
```

这里a是声明为指针，而b不是。但是在go里，

```go
var a, b *int
```

a，b同时都是指针。这样更加清晰而且通用。
同样的，:=声明要求变量声明的顺序应该跟 := 一样，所以：

```go
var a uint64 = 1
```

跟下面这个效果是一样的。

```go
a := uint64(1)
```

##### 3、 为什么没有指针运算？

安全性。如果没有指针运算，是可以创造一门语言，它不会因为访问非法地址而导致不正确。
编译和硬件技术其实已经可以使得在loop里面，用指针访问和用数组索引访问一样的速度。
同样的，没有指针运算可以简化垃圾回收的问题。

##### 4、什么++和--不是表达式？ 为什么用后缀不是前缀？

没有指针的运算，就不再需要前缀和后缀自增的操作符。
把他们从语法中移除之后，表达语法变得简单，而且之前的顺序对++和--运算的影响的问题也不再存在（例如，p\[i\]=q\[++i\]这样的语法）。 

##### 5、为什么有大括号而没有分号？为什么不能把 { 符号单独放在一行？

Go使用大括号来对语句进行分组，这个对任何使用过C语言的程序员都很熟悉。
而分号主要用户语法分析，而不是给人使用的，所以我们希望尽量地删除它们。
要达到这个目标，go使用了BCPL的trick：在实际的语法中，使用分号来区分不同语句，但是它是通过语法分析器，在每一行可能是语句结束的最后位置插入分号。
这个在实际中很管用，但是对于大括号，会限制它的使用。例如，开括号不能单独在一行出现。

有人认为，语法分析器应该能提前识别这个。但我们不认同。
因为Go的代码是要通过gofmt来进行标准化的，因而我们有时必须对代码风格做抉择。
这些风格可能跟C或者Java不同，但是go是不同的语言，它独特的风格跟其他语言一样优秀。
更重要的是，go语言这种强制的单一风格，可以避免特定风格的缺点。
同样需要注意的是，交互式的go可以使用标准的语法，即一次只有一行，而不需要特殊的规则。

##### 6、为什么要做垃圾回收？它会不会代价太大？

系统编程最繁琐枯燥的事情之一就是管理分配的对象的生命周期。
像C这样的语言，它是人工手动进行处理的，这样花费程序员大量的时间，而且经常导致致命的bug。
即便像C++和Rust这样提供一些机制协助，但是这些机制其实会影响到软件的设计，通常要实现这些机制比原本要实现的功能还复杂。
我们认为应该减少程序员这方面的问题，幸好近年来GC技术的发展，给了我们信心可以用较小的代价解决这个问题，而且它的延时足够低，使得在网络环境下也是可用的方法。

大多数并发编程根源上在生命周期管理时有一个问题：随着对象在线程之间传递，要保证他们能够被安全地释放会很困难。
自动的垃圾回收使得并发代码很难写。当然，在并发环境下实现垃圾回收本身也是一个挑战，但是我们只要解决一次，就能帮到所有人。

最后，除了并发，还有一个原因是，垃圾回收使得接口变得简洁，不再需要指明内存需要如何管理。

当然，这不意味着今年像rust语言在资源管理方面引入的新的思路的方向是错误的；我们鼓励这些工作，而且关注它们的演变。
不过go使用了传统的方式来解决对象的声明周期管理，也即是GC，而且只使用GC。

当前的实现是使用mark-and-sweep回收器。
如果机器是多处理器，回收器会单独运行在一个核上，并跟主程序并行。
近年来collector的主要工作是把暂停时间减少到sub-millisecond，即便是对大的堆也同样适用，除非是在网络环境下做垃圾回收。
这方面的算法还在优化，以减少额外开销和延时。
在2018的[ISMM keynote](https://blog.golang.org/ismmkeynote)上Rick Hudson的团队描述了进展，并提出了设想。

对于性能的问题，还需要记住的是，go提供给程序员控制内存布局和分配的方式，这个是典型的垃圾回收语言做不到的。
细致的程序员如果使用得当，会显著地减少gc的损耗；可以在[这篇文章](https://blog.golang.org/profiling-go-programs)看到更多的示例，包括go的profiling工具。

